<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Use elevationInfo in 3D visualization - 4.5</title>
<style>
	html,
	body,
	#viewDiv {
		padding: 0;
		margin: 0;
		height: 100%;
		width: 100%;
	}

	#elevationDiv {
		position: absolute;
		top: 12px;
		right: 12px;
		padding: 12px;d
		background-color: rgba(0, 0, 0, 0.5);
		color: white;
	}
	
	#queryDiv {
		position: absolute;
		bottom: 12px;
		left: 12px;
		padding: 12px;
		background-color: rgba(0, 0, 0, 0.5);
		color: white;
	}
</style>

<link rel="stylesheet" href="https://js.arcgis.com/4.5/esri/css/main.css">
<script src="https://js.arcgis.com/4.5/"></script>

<script>
	require([
		"esri/Map",
		"esri/views/SceneView",
		"esri/layers/FeatureLayer",
		"esri/layers/GroupLayer",
		"esri/layers/MapImageLayer",
		"esri/renderers/SimpleRenderer",
		"esri/renderers/Renderer",
		"esri/geometry/Point",
		"esri/geometry/Polygon",
		"esri/symbols/PointSymbol3D",
		"esri/symbols/ObjectSymbol3DLayer",
		"esri/widgets/LayerList",
		"esri/widgets/Legend",
		"esri/tasks/support/Query",
		"esri/tasks/QueryTask",
		"esri/core/urlUtils",
		"esri/core/Collection",
		"esri/layers/GraphicsLayer", 
		"esri/Graphic",
		"esri/core/watchUtils",
		"dojo/on",
		"dojo/dom",
		"dojo/domReady!"
	], function(Map, SceneView, FeatureLayer, GroupLayer, MapImageLayer, SimpleRenderer, Renderer, Point, Polygon, PointSymbol3D, ObjectSymbol3DLayer, LayerList, Legend, Query, QueryTask, urlUtils, GraphicsLayer, Graphic, watchUtils, Collection, on, dom) {	
	// If True, then each function will print to the console what it's doing, at all times, in great detail. 
	// Useful for debugging and tracking down errors.
	var verbose = true;
	// Some configuration variables
	var layer_spacing = 20; // The initial spacing of the layers
	var initial_EM_height = 100; // The initial height of the unit-end markers
	var UEM_ID = null

	// Define the map service that all of the data is loaded from
	var szMapService = new MapImageLayer({
		url: "https://alaskafisheries.noaa.gov/arcgis/rest/services/ShoreZone/MapServer"
	});
	
	// Create the Map
	var map = new Map({
		basemap: "streets",
		ground: "world-elevation"
	});
	// A list that we will use to keep track of the order that the layers are added in. Important for stacking order
	map.layer_order = [];
	
	// Create the SceneView
	var view = new SceneView({
		container: "viewDiv",
		map: map,
		camera: {
			position: [-135, 58.73, 5000],
			heading: 20,
			tilt: 60
		}
	});
	
	/** 
	Takes in a layer and, based on it's visibility status, calls the appropriate function in the StackManager object.
	Restack layers must be called after this in order for the new layer order to be reflected in the map.
	*/
	function orderLayers( layer ) {
		printIfVerbose( "Adjusting order of map layers..." );
		/*/ We don't care about group layers to be considered in the layer order, so we'll kick them out here:
		if( layer.type != 'feature' ) {
			return;
		}
		*/
		// Layer's can only have one parent, so by adding the layer to the layer_order list directly, we remove it from the map.
		// So instead we'll just keep track of the layers' ID values. 
		// fireOnVisibilityChange fires when a layer gets turned on or off, but can't tell us which it was.
		// So we have to check ourselves, and then act appropriately
		if( layer.visible == true ) {
			// If this is the case, then the layer was just turned on, and needs to be put on top of the stack.
			stackManager.add(layer);
		}
		else {
			// If this is the case, then the layer was just hidden, and we need to remove it from the stack entirely.
			stackManager.remove(layer);
		}
		// Super simple stuff
	}
	
	// Function that redraws the layers into the order that they have been added to the map.
	// Respects the soveriegnty of the UEM, which will always be at offset = 0
	function restackLayers() {
		printIfVerbose( 'Restacking map layers...' );
		// First we retrieve the offset value from the appropriate Dom element
		var offset;
		try {
			offset = parseFloat(offsetInput.value, 10);
		} catch (e) {
			return e;
		}
		// Now we know how far apart to space our layers
		var i = 0 // Our iteration index
		stackManager.order.forEach(function(layer_id) {
			// We never adjust the offset of the UEM
			if ( layer_id != map.UEM_ID ) {
				// map.layer_order only keeps track of the layer IDs, so we need to do a lookup to get ahold of the actual layer
				layer = findMapLayerById( layer_id );
				printIfVerbose( 'Considering visibility status of: ' + layer.title );
				printIfVerbose( layer );
				// We only want to stack up visible layers.
				if (layer.visible == true) {
					printIfVerbose( 'Adding ' + layer.title + ' to the top of the stack.' );
					// Now we just manually adjust the offset
					layer.elevationInfo = {
						mode: "relative-to-ground",
						offset: i * offset
					};
					// ...and increment i to account for the addition of another layer.
					i++;
				}
			}
		});
		// Update Unit End Markers height to be equal to the highest layer, unless there's only one layer. Then make it equal to 1 * the offset height
		if ( i - 1 < 1 ) {
			i = 1	
		}
		else {
			i = i - 1 // i was incremented once after the last layer was added, so we need to account for that here.
		}
		UEM = map.findLayerById( map.UEM_ID )
		// This function gets called during startup before UEM has been defined and added to the map.
		// This prevents the inevietable error.
		if ( UEM != null ) {
			UEM.renderer = createBorderRenderer( (i)*offset );
		}
	};
	
	/**
	Object which is responsible for maintaining the order of the layers as they are turned on and off in the list display.
	Does this by maintaining an array of IDs for all layers in the map, which is kept up to date as layers are addded and
	removed, and then providing that array when it is time to restack the layers.
	*/
	var stackManager = new Object({
		/**
		This array will hold the ids of the map layers in the order in which they should be displayed. Non visible 
		layer_ids will still be held in the array.
		The array will be read from back to front (n -> 0), and each visible layer will be added to the stack
		as it is encountered. 
		
		In order to put a layer on the top of the stack, first remove the layer_id from the stack by calling
		order.splice(index, 1), then call 'order.unshift(layer_id)' which will append the layer id
		to the front of the array, effectively putting it on top of the stack.
		
		When removing a layer, again call order.splice(index, 1), then call order.push(layer_id). This will push 
		the layer to the end of the array.
		*/
		order: [],
		// Add the id's from a list of layers into the order
		populate_order: function(layers) {
			printIfVerbose( 'SM: Populating order...' );
			layers.forEach(
				function(layer){					 
					// We don't want to add these layers to our order
					if (layer.title != 'World Street Map' && layer.title != "Terrain3D") {
						printIfVerbose( 'SM: Adding ' + layer.title + ' ID ' + layer.id + ' to order.' );
						this.order.push(layer.id);
						printIfVerbose( 'SM: ' + layer.title + ' ID added.' );
					}
				}, this
			);
		},
		/**Adds a layer to the ordered stack, along with it's children as is appropriate*/
		add: function(layer) {
			printIfVerbose( 'SM: Adding layer to the top of the stack order...' );
			this.order.unshift(
				// This function returns the element we're removing, so we can use that return value to re-insert the value elsewhere
				this.order.splice(
					// First find the index of the layer_id we're looking for
					this.order.indexOf(layer.id),
					// And we're only removing one element.
					1
				)
			)
			// Now we check to see if the layer has any sublayers, and if it does we should load them in.
			printIfVerbose( 'SM: Checking if layer has sublayers...' );
			if (layer.sublayers != null) {
				printIfVerbose( 'It does. Adding sublayers to top of stack order...' );
				layer.sublayers.forEach(function(sublayer){
					add(sublayer);
				});
			} else {
				printIfVerbose( 'SM: It does not.' );
			}
		},
		/**Removes a layer from the ordered stack, along with it's children.*/
		remove: function(layer) {
			printIfVerbose( 'SM: Moving layer to the bottom of the stack order...' );
			this.order.push(
				// This function returns the element we're removing, so we can use that return value to re-insert the value elsewhere
				this.order.splice(
					// First find the index of the layer_id we're looking for
					this.order.indexOf(layer.id),
					// And we're only removing one element.
					1
				)
			)
			// Now we check to see if the layer has any sublayers, and if it does we should load them in.
			printIfVerbose( 'SM: Checking if layer has sublayers...' );
			if (layer.sublayers != null) {
				printIfVerbose( 'It does. Moving sublayers to bottom of stack order...' );
				layer.sublayers.forEach(function(sublayer){
					add(sublayer);
				});
			} else {
				printIfVerbose( 'SM: It does not.' );
			}
			printIfVerbose( 'SM: New order of stack:' );
			this.order.forEach( function(layer_id) {
				var title = findMapLayerById(layer_id).title;
				printIfVerbose( 'SM: ' + title );
			});
		},
		/**Returns true iff all higher order parents of the given layer are visible.
		 * Calling this function effectively assumes that the passed layer is visible.*/
		allAncestorsVisible: function(layer) {
			if (layer.parent == null) {
				return true; // If the layer has no parent, then effectively all parents are visible
			} else {
				if (layer.parent.visible == true) {
					return allAncestorsVisible(layer.parent);
				} else {
					return false;
				}
			}
		}
	});

	function printIfVerbose( msg ) {
		if( verbose == true ) {
			console.log( msg );
		}
	}
	
	function createLayerList() {
		// Object that displays all available layers and their visiblity status	  
		var layerList = new LayerList({
			view: view
		});
		// Add the layer list to the view
		view.ui.add(layerList, {
			position: 'bottom-right'
		});
	}
  
	// Function that builds and returns the layerInfos object for the legend widget. Just references the map object, doesn't need any parameters.
	function getLayerInfos() {
		var layerInfos = [];
		// Here we iterate through all of the layers in the map and add them to the layerInfos object
		for (var index in map.allLayers.items) {
			var lyr = map.allLayers.items[index] 
			if (lyr.title == 'World Street Map' || lyr.title == "Terrain3D") {
				continue; // We don't want to add these layers to our legend
			}
			// Add the layer to the object.
			layerInfos.push({
				layer: lyr,
				title: lyr.title
			});
		}
		return layerInfos;
	}
  
	// Function that creates the Legend widget. Legend automatically references all layers in the map, excluding the World Street Map and the Terrain 3D Layers
	function createLegend() {  
		var legend = new Legend({
			view: view,
			layerInfos: getLayerInfos()  // This is where the magic happens
		});

		// Add widget to the bottom left corner of the view
		view.ui.add(legend, "bottom-left");
	}	 
  
	// Creates and returns a simple renderer which produces the end of unit markers at the specified height (h)
	function createBorderRenderer( h ) {
		var borderSymbol = new PointSymbol3D({
			symbolLayers: [new ObjectSymbol3DLayer({
				width: 10,  // diameter of the object from east to west in meters
				height: h,  // height of the object in meters
				depth: 10,  // diameter of the object from north to south in meters
				resource: { primitive: "cylinder" },
				material: { color: "grey" }
			})]
		});

		var borderRenderer = new SimpleRenderer({
			symbol: borderSymbol
		});
	  
		return borderRenderer
	}
	
	// Function that fires every time any layer changes it's visibility state.
	// Function will iterate through every layer visible in the layerList, will set their offsets incrementaly, effectively maintaining a collapsed stack
	function fireOnVisibilityChange( lyr ) {
		printIfVerbose( 'Visibility of ' + lyr.title + ' has changed.' );
		orderLayers( lyr );
		restackLayers();
	}

	// Function that fires whenever the camera finishes changing position
	function fireOnCameraChange() {
		printIfVerbose( 'Camera has changed position in some way.' );
		view.camera.hasChanged = false; // Register the fact that we have accounted for this change.	
		updateVisibleFeatures();
	}
  
	function setWatchers() {
		// Register events to the controls
		var offsetInput = dom.byId("offsetInput");
		on(offsetInput, "blur", restackLayers());
		on(offsetInput, "keypress", elevationOffsetKeypress);
		
		map.allLayers.forEach(
			lyr => lyr.watch( "visible", 
				function( visible ){
					fireOnVisibilityChange( lyr );
				}
			));
		map.allLayers.on( "changes", function(event) { // Placeholder watcher. Fires every time a layer is added to or removed from the map.
			console.log( 'map layers change' );
		});
		
		// These next three watchers work in concert to call the function fireOnCameraChange exactly once every time the camera moves, but only after it finishes moving. Actually kinda tricky, so please be careful with these statements.
		view.watch("camera",
			function( camera ) {
				camera.hasChanged = true;
			});
		view.watch("animation",
			function( animating ) {
				if( animating == null ) {
				// If execution reaches this line, then the animation has just finished, not just started.
					if( view.interacted == true ) {
					// If execution reaches this line, it means that the user finished interacting with the view before the animation had finished processing.
						if( view.camera.hasChanged == true ) {
							fireOnCameraChange();
						}
					}
				}
			});
		view.watch("interacting",
			function( interacting ) {
				// If this function has fired, and animation == null, that means that whatever interaction was taking place has just finished
				if( interacting == false ) {
					if( view.animation == null ) {
					// If execution reaches this line, then the view is not processing an animation
						if( view.camera.hasChanged == true ) {
							fireOnCameraChange();
						}
					} 
					else {
						view.interacted = true; // Set a flag for the animation watcher to see when the animation finishes.
					}
				}
			});
	}
  
	// Function to streamline our checking
	// Accepts a layer and should return true if that layer is a layer that we want in the map.
	function isDesiredLayer( layer ) {
		title = layer.title;
		// Since all sublayers are build from their parent group layers, the only layers we actually need to look for are these three
		if ((title == "Biological Attributes" || title == "Response Attributes" || title == "Derived ShoreZone Attributes")){
			return true;
		}
		return false;
	}
	
	function buildGroupLayer( layer ) {
		printIfVerbose( layer.title + ' is a Group layer. Creating client side group layer...' );
		
		groupLayer = new GroupLayer({
			visible: false,
			url: layer.url,
			title: layer.title,
			listMode: 'show', // Indicates that all child layers should be shown in the list display
			visibilityMode: 'independent', // Indicates that children layers should inherit their visibility status from their parents
		});
		
		layer.sublayers.forEach(function(child_layer){
			printIfVerbose( 'Building ' + child_layer.title + ' as a sublayer for ' + layer.title ); 
			sublayer = buildLayer( child_layer );
			groupLayer.add( sublayer );
		});
		printIfVerbose( 'Added ' + groupLayer.layers.length + ' sublayers to ' + groupLayer.title );

		return groupLayer;
	}
	
	function buildFeatureLayer( layer ) {
		printIfVerbose( layer.title + ' is a Feature layer. Creating client side feature layer.' );
		layer_url = layer.url;
		featLayer = new FeatureLayer({
			visible: false, // Every layer starts out hidden.
			url: layer_url,
			elevationInfo: {
				  mode: "relative-to-ground",
				  offset: 0
			}
		});
		return featLayer;
	}
	
	function buildLayer( layer ) {
		printIfVerbose( 'Determining if ' + layer.title + ' is a feature layer or a group layer.' );
		outLayer = null;
		if( layer.sublayers == null ) { // If there are no sublayers, then the layer is a feature layer
			outLayer = buildFeatureLayer( layer )
		}
		else{ // Otherwise it's a group  layer.
			outLayer = buildGroupLayer( layer )
		}
		return outLayer; 
	}
	
	function loadLayers() {
		for (var index in szMapService.allSublayers.items) {
			layer = szMapService.allSublayers.items[index];
			if ( isDesiredLayer( layer )==true ) { 
				// Create the feature layer from the REST service
				builtLayer = buildLayer( layer ); // layer is a promise returned by the 
				printIfVerbose( 'Adding ' + layer.title + ' to map.' );
				map.add( builtLayer );
			}
		}
	}
	
	function findMapLayerById( id ) {
		printIfVerbose( 'Looking for layer with id == ' + id );
		return map.allLayers.find(function(layer){
			printIfVerbose( 'Considering layer ' + layer.title + ' with ID ' + layer.id + '...' );
			if (layer.id == id) {
				printIfVerbose( 'Returning ' + layer.title );
				return layer;
			}
		});
	}
  
	// Create Unit End Markers as a FeatureLayer, set the elevation mode and add to the map
	function buildUEM( height ) {
		var UEM = new FeatureLayer({
		  title: "Unit End Marker",
		  url: "https://alaskafisheries.noaa.gov/arcgis/rest/services/ShoreZoneMapService/MapServer/58",
		  //definitionExpression: "Start_PHY_IDENT LIKE '10/04%'",
		  elevationInfo: {
			mode: "relative-to-ground",
			offset: 0
		  },
		  renderer: createBorderRenderer( height )
		});
		return UEM;
	}

	// Register events to the controls
	var offsetInput = dom.byId("offsetInput");
	
	on(offsetInput, "blur", restackLayers());
	on(offsetInput, "keypress", elevationOffsetKeypress);
	
	/* Implements a query button, useful for debugging the query infrastructure.
	var queryInput = dom.byId("queryButton");
	queryInput.onclick = function() {
		updateVisibleFeatures();
	}; */
  
	function elevationOffsetKeypress(ev) {
	  if (ev.which === 13) {
		  restackLayers();
	  }
	}
	
	function updateVisibleFeatures() {
		printIfVerbose( 'Updating visible features.' );
		var result = sceneViewExtent(view);
		// If the returned extent is null, that probably means that the extent has at least one corner in space, so it can't be used. By simply ending the function here, we avoid the inevietable error that will be thrown later, and crash the program.
		if( result == null ) {
			printIfVerbose( 'View extent is NULL. View likely extends into space.' );
			return;
		}
		printIfVerbose( 'View extent succesffuly retrieved. Forming definition expression' );
		ext3D = result.extent;
		var defExpr = "INSIDE_X > " + ext3D.xmin + " AND INSIDE_X < " + ext3D.xmax + " AND INSIDE_Y > " + ext3D.ymin + " AND INSIDE_Y < " + ext3D.ymax;
		// The UEM fields are labeled slightly differently, and so it needs it's own sligtly different definition expression
		var UEMdefExpr = "POINT_X > " + ext3D.xmin + " AND POINT_X < " + ext3D.xmax + " AND POINT_Y > " + ext3D.ymin + " AND POINT_Y < " + ext3D.ymax;
		// defExpr now represents a definition expression that will limit the features drawn to those fully visible in the current extent.
		printIfVerbose( 'Now appending definition expression to each layer:' );
		map.allLayers.forEach(function(layer) {
			printIfVerbose( 'Adding definition expression to ' + layer.title + '...' );
			if( layer.id == map.UEM_ID ) {			
				// We have the give the UEM it's specially tailored definition expression
				layer.definitionExpression = UEMdefExpr;
			}
			else {
				// All other layers recieve the same expression
				layer.definitionExpression = defExpr;
			}
		});
		printIfVerbose( 'Definition expression successfully added to all layers.' )
	}
  
	// Calculate true extent of tilted 3D view.  Returns a Polygon.
	// Parameters:
	//   view is the SceneView being used
	//   m is an optional margin, in pixels.  Defaults to 0.
	function sceneViewExtent(view, m) {
		printIfVerbose( 'Determining scene view extent...' )
		if (m === undefined)
			m = 0;
		// Make an array of the corners of the view container (in pixels)
		var maxX = view.container.offsetWidth;
		var maxY = view.container.offsetHeight;
		var screenPoints = [[m,m], [maxX-m,m], [maxX-m,maxY-m], [m,maxY-m]];
		var mapPoints = [];
		for (var p=0; p<screenPoints.length; p++) {
			var screenPoint = new Point({x: screenPoints[p][0], y: screenPoints[p][1], z: 0});
			var mapPoint = view.toMap(screenPoint);
			if (!mapPoint)
				return null;
			mapPoints.push([mapPoint.x, mapPoint.y, mapPoint.z]);
		}
		mapPoints.push(mapPoints[0]);
		var newPolygon = new Polygon(mapPoints);
		return newPolygon;
	}


	  
	function getSubLayerID(mapImageLayer, subLayerName) {
		var li = mapImageLayer.allSublayers;
		var layerName = subLayerName[0];
		for (var i=0; i<li.length; i++) {
			if (li.items[i].title==subLayerName)
				 return li.items[i].id;
			}
		return -1;
	}
	  
	// Function that performs all of the necessary one-time setup when the application is first loaded.
	// Function is not executed until the ShoreZone map service is fully loaded.
	function init(){   
		console.log( 'LOADING LAYERS...' );
		loadLayers(); // Load the layers into the map.
		console.log( 'BUILDING UEM...' );
		UEM = buildUEM( initial_EM_height );
		map.add( UEM );
		// Once we've assined the UEM layer to the Map, the layer has an ID that we can record to make later references to the layer easy
		map.UEM_ID = UEM.id;
		// Add watchers to all of the layers. Each watcher fires when it's layer's visibility changes. Calls fireOnVisibilityChange()
		console.log( 'SETTING WATCHERS...' );
		setWatchers(); 
		// Create the legend widget, add the layers to it, and add it to the map.
		console.log( 'BUILDING LEGEND...' );
		createLegend();
		console.log( 'BUILDING LAYER LIST...' );
		createLayerList();
		printIfVerbose( 'POPULATING STACK MANAGER...' );
		printIfVerbose( map.allLayers.items );
		stackManager.populate_order( 
			// Pass the list of all layers in the map:
			map.allLayers
		);
		printIfVerbose( 'ADDED ' + stackManager.order.length + ' LAYERS TO THE STACK MANAGER.' )
		setTimeout(
			function(){ 
				console.log( 'report' );
				console.log( map ); 
			}, 
			3000
		);
	};
	
	// Now that all of our code is defined and ready, we load the map service, which will trigger the initialization of the entire app.
	szMapService.load()  
	// Function that fires once the szMapService has completely loaded. Since we have to wait for that to initialize basically every part of the web app, we just wait and then call the init() function, which intitializes all of the layers and widgets that we need.
	szMapService.then(
		function() {
			init();
		}
	);
});
</script>
</head>

<body>
<div id="viewDiv"></div>
<div id="elevationDiv">
	<table>
		<tr>
			<td>Layer spacing:</td>
			<td><input id="offsetInput" type="text" size="5" value="100"></td>
		</tr>
		<!--<tr> Adds a button to the UI, which can be linked to the query testing functionality a few lines above.
			<td><input type="button" id="queryButton" name="queryButton" value="Query"</td>
		</tr>-->
	</table>
</div>
</body>
</html>