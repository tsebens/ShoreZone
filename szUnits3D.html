<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Use elevationInfo in 3D visualization - 4.5</title>
<style>
	html,
	body,
	#viewDiv {
		padding: 0;
		margin: 0;
		height: 100%;
		width: 100%;
	}

	#elevationDiv {
		position: absolute;
		top: 12px;
		right: 12px;
		padding: 12px;d
		background-color: rgba(0, 0, 0, 0.5);
		color: white;
	}
	
	#queryDiv {
		position: absolute;
		bottom: 12px;
		left: 12px;
		padding: 12px;
		background-color: rgba(0, 0, 0, 0.5);
		color: white;
	}
</style>

<link rel="stylesheet" href="https://js.arcgis.com/4.5/esri/css/main.css">
<script src="https://js.arcgis.com/4.5/"></script>

<script>
	require([
		"esri/Map",
		"esri/views/SceneView",
		"esri/layers/FeatureLayer",
		"esri/layers/GroupLayer",
		"esri/layers/MapImageLayer",
		"esri/renderers/SimpleRenderer",
		"esri/renderers/Renderer",
		"esri/geometry/Point",
		"esri/geometry/Polygon",
		"esri/symbols/PointSymbol3D",
		"esri/symbols/ObjectSymbol3DLayer",
		"esri/widgets/LayerList",
		"esri/widgets/Legend",
		"esri/tasks/support/Query",
		"esri/tasks/QueryTask",
		"esri/core/urlUtils",
		"esri/core/Collection",
		"esri/layers/GraphicsLayer", 
		"esri/Graphic",
		"esri/core/watchUtils",
		"dojo/on",
		"dojo/dom",
		"dojo/domReady!"
	], function(Map, SceneView, FeatureLayer, GroupLayer, MapImageLayer, SimpleRenderer, Renderer, Point, Polygon, PointSymbol3D, ObjectSymbol3DLayer, LayerList, Legend, Query, QueryTask, urlUtils, GraphicsLayer, Graphic, watchUtils, Collection, on, dom) {	
	// If True, then each function will print to the console what it's doing, at all times, in great detail. 
	// Useful for debugging and tracking down errors.
	var verbose = false;
	// Some configuration variables
	var layer_spacing = 20; // The initial spacing of the layers
	var initial_EM_height = 100; // The initial height of the unit-end markers
	var UEM_ID = null

	// Define the map service that all of the data is loaded from
	var szMapService = new MapImageLayer({
		url: "https://alaskafisheries.noaa.gov/arcgis/rest/services/ShoreZone/MapServer"
	});
	
	// Create the Map
	var map = new Map({
		basemap: "streets",
		ground: "world-elevation"
	});
	// A list that we will use to keep track of the order that the layers are added in. Important for stacking order
	map.layer_order = [] 
	
	// Create the SceneView
	var view = new SceneView({
		container: "viewDiv",
		map: map,
		camera: {
			position: [-135, 58, 20914],
			heading: 20,
			tilt: 80
		}
	});

	function printIfVerbose( msg ) {
		if( verbose == true ) {
			console.log( msg );
		}
	}
	
	function createLayerList() {
		// Object that displays all available layers and their visiblity status	  
		var layerList = new LayerList({
			view: view
		});
		// Add the layer list to the view
		view.ui.add(layerList, {
			position: 'bottom-right'
		});
	}
  
	// Function that builds and returns the layerInfos object for the legend widget. Just references the map object, doesn't need any parameters.
	function getLayerInfos() {
		var layerInfos = [];
		// Here we iterate through all of the layers in the map and add them to the layerInfos object
		for (var index in map.allLayers.items) {
			var lyr = map.allLayers.items[index] 
			if (lyr.title == 'World Street Map' || lyr.title == "Terrain3D") {
				continue; // We don't want to add these layers to our legend
			}
			// Add the layer to the object.
			layerInfos.push({
				layer: lyr,
				title: lyr.title
			});
		}
		return layerInfos;
	}
  
	// Function that creates the Legend widget. Legend automatically references all layers in the map, excluding the World Street Map and the Terrain 3D Layers
	function createLegend() {  
		var legend = new Legend({
			view: view,
			layerInfos: getLayerInfos()  // This is where the magic happens
		});

		// Add widget to the bottom left corner of the view
		view.ui.add(legend, "bottom-left");
	}	 
  
	// Creates and returns a simple renderer which produces the end of unit markers at the specified height (h)
	function createBorderRenderer( h ) {
		var borderSymbol = new PointSymbol3D({
			symbolLayers: [new ObjectSymbol3DLayer({
				width: 10,  // diameter of the object from east to west in meters
				height: h,  // height of the object in meters
				depth: 10,  // diameter of the object from north to south in meters
				resource: { primitive: "cylinder" },
				material: { color: "grey" }
			})]
		});

		var borderRenderer = new SimpleRenderer({
			symbol: borderSymbol
		});
	  
		return borderRenderer
	}
	
	// Function that fires every time any layer changes it's visibility state.
	// Function will iterate through every layer visible in the layerList, will set their offsets incrementaly, effectively maintaining a collapsed stack
	function fireOnVisibilityChange( lyr ) {
		orderLayers( lyr );
		restackLayers();
	}

	// Function that fires whenever the camera finishes changing position
	function fireOnCameraChange() {
		printIfVerbose( 'Camera has changed position in some way.' );
		view.camera.hasChanged = false; // Register the fact that we have accounted for this change.	
		updateVisibleFeatures();
	}
  
	function setWatchers() {
		// Register events to the controls
		var offsetInput = dom.byId("offsetInput");
		on(offsetInput, "blur", restackLayers());
		on(offsetInput, "keypress", elevationOffsetKeypress);
		
		map.layers.forEach(
			lyr => lyr.watch( "visible", 
				function( visible ){
					fireOnVisibilityChange( lyr );
				}
			));
		map.layers.on( "changes", function(event) { // Placeholder watcher. Fires every time a layer is added to or removed from the map.
			console.log( 'map layers change' );
		});
		
		// These next three watchers work in concert to call the function fireOnCameraChange exactly once every time the camera moves, but only after it finishes moving. Actually kinda tricky, so please be careful with these statements.
		view.watch("camera",
			function( camera ) {
				camera.hasChanged = true;
			});
		view.watch("animation",
			function( animating ) {
				if( animating == null ) {
				// If execution reaches this line, then the animation has just finished, not just started.
					if( view.interacted == true ) {
					// If execution reaches this line, it means that the user finished interacting with the view before the animation had finished processing.
						if( view.camera.hasChanged == true ) {
							fireOnCameraChange();
						}
					}
				}
			});
		view.watch("interacting",
			function( interacting ) {
				// If this function has fired, and animation == null, that means that whatever interaction was taking place has just finished
				if( interacting == false ) {
					if( view.animation == null ) {
					// If execution reaches this line, then the view is not processing an animation
						if( view.camera.hasChanged == true ) {
							fireOnCameraChange();
						}
					} 
					else {
						view.interacted = true; // Set a flag for the animation watcher to see when the animation finishes.
					}
				}
			});
	}
  
	// Function to streamline our checking 
	function isDesiredLayer( layer ) {
		parent = extractFirstAncestor( layer );
		if ((parent == "Biological Attributes" || parent == "Response Attributes" || parent == "Derived ShoreZone Attributes")&&layer.sublayers==null&&layer.title!='Habitat Class'){
			return true;
		}
		return false;
	}
	// Loads all of the appropriate layers from szMapService into the map.
	function loadLayers() {
		for (var index in szMapService.allSublayers.items) {
			layer = szMapService.allSublayers.items[index];
			if ( isDesiredLayer( layer )==true ) { 
				// Create the feature layer from the REST service
				layer_url = layer.url;
				layer_title = layer.title;
				featLayer = new FeatureLayer({
					visible: false, // Every layer starts out hidden.
					url: layer_url,
					title: layer_title,
					elevationInfo: {
						  mode: "relative-to-ground",
						  offset: 0
					}
				});
				map.add( featLayer )
				featLayer.load()
			}
		}
	}

	// Recursive function that determines the highest ancestor of the given layer
	function extractFirstAncestor( layer ) {
		if ( layer.parent.title == szMapService.title ) {
			  return layer.title;
		}
		else {
			return extractFirstAncestor( layer.parent )
		}
	}
  
	function orderLayers( layer ) {
		
		// Layer's can only have one parent, so by adding the layer to the layer_order list directly, we remove it from the map.
		// So instead we'll just keep track of the layers' ID values. 
		if( layer.visible == true ) {
			// If this is the case, then the layer was just turned on, and needs to be put on top of the stack.
			map.layer_order.push( layer.id );
		}
		else {
			// If this is the case, then the layer was just hidden, and we need to remove it from the stack entirely.
			index = map.layer_order.indexOf( layer.id );
			map.layer_order.splice( index, 1 );
		}
	}
	
	// Function that redraws the layers into the order that they have been added to the map.
	// Respects the soveriegnty of the UEM, which will always be at offset = 0
	function restackLayers() {
		// First we retrieve the offset value from the appropriate Dom element
		var offset;
		try {
			offset = parseFloat(offsetInput.value, 10);
		} catch (e) {
			return e;
		}
		// Now we know how far apart to space our layers
		var i = 0 // Our iteration index
		for( var index in map.layer_order ) {
			// map.layer_order only keeps track of the layer IDs, so we need to do a lookup to get ahold of the actual layer
			layer_id = map.layer_order[index]
			if ( layer_id == map.UEM_ID ) {
				// We never adjust the offset of the UEM
				continue;
			}
			layer = map.findLayerById( layer_id );
			// Now we just manually adjust the offset
			layer.elevationInfo = {
					mode: "relative-to-ground",
					offset: i * offset
				}
			i++;
		}
		// Update Unit End Markers height to be equal to the highest layer, unless there's only one layer. Then make it equal to 1 * the offset height
		if ( i - 1 < 1 ) {
			i = 1	
		}
		else {
			i = i - 1 // i was incremented once after the last layer was added, so we need to account for that here.
		}
		UEM = map.findLayerById( map.UEM_ID )
		// This function gets called during startup before UEM has been defined and added to the map.
		// This prevents the inevietable error.
		if ( UEM != null ) {
			UEM.renderer = createBorderRenderer( (i)*offset );
		}
	};
  
	// Create Unit End Markers as a FeatureLayer, set the elevation mode and add to the map
	function buildUEM( height ) {
		var UEM = new FeatureLayer({
		  title: "Unit End Marker",
		  url: "https://alaskafisheries.noaa.gov/arcgis/rest/services/ShoreZoneMapService/MapServer/58",
		  //definitionExpression: "Start_PHY_IDENT LIKE '10/04%'",
		  elevationInfo: {
			mode: "relative-to-ground",
			offset: 0
		  },
		  renderer: createBorderRenderer( height )
		});
		return UEM;
	}

	// Register events to the controls
	var offsetInput = dom.byId("offsetInput");
	
	on(offsetInput, "blur", restackLayers());
	on(offsetInput, "keypress", elevationOffsetKeypress);
	
	/* Implements a query button, useful for debugging the query infrastructure.
	var queryInput = dom.byId("queryButton");
	queryInput.onclick = function() {
		updateVisibleFeatures();
	}; */
  
	function elevationOffsetKeypress(ev) {
	  if (ev.which === 13) {
		  restackLayers();
	  }
	}
	
	function updateVisibleFeatures() {
		printIfVerbose( 'Updating visible features.' );
		var result = sceneViewExtent(view);
		// If the returned extent is null, that probably means that the extent has at least one corner in space, so it can't be used. By simply ending the function here, we avoid the inevietable error that will be thrown later, and crash the program.
		if( result == null ) {
			printIfVerbose( 'View extent is NULL. View likely extends into space.' );
			return;
		}
		printIfVerbose( 'View extent succesffuly retrieved. Forming definition expression' );
		ext3D = result.extent;
		var defExpr = "INSIDE_X > " + ext3D.xmin + " AND INSIDE_X < " + ext3D.xmax + " AND INSIDE_Y > " + ext3D.ymin + " AND INSIDE_Y < " + ext3D.ymax;
		// The UEM fields are labeled slightly differently, and so it needs it's own sligtly different definition expression
		var UEMdefExpr = "POINT_X > " + ext3D.xmin + " AND POINT_X < " + ext3D.xmax + " AND POINT_Y > " + ext3D.ymin + " AND POINT_Y < " + ext3D.ymax;
		// defExpr now represents a definition expression that will limit the features drawn to those fully visible in the current extent.
		printIfVerbose( 'Now appending definition expression to each layer:' );
		map.layers.forEach(function(layer) {
			printIfVerbose( 'Adding definition expression to ' + layer.title + '...' );
			if( layer.id == map.UEM_ID ) {			
				// We have the give the UEM it's specially tailored definition expression
				layer.definitionExpression = UEMdefExpr;
			}
			else {
				// All other layers recieve the same expression
				layer.definitionExpression = defExpr;
			}
		});
		printIfVerbose( 'Definition expression successfully added to all layers.' )
	}
  
	// Calculate true extent of tilted 3D view.  Returns a Polygon.
	// Parameters:
	//   view is the SceneView being used
	//   m is an optional margin, in pixels.  Defaults to 0.
	function sceneViewExtent(view, m) {
		printIfVerbose( 'Determining scene view extent...' )
		if (m === undefined)
			m = 0;
		// Make an array of the corners of the view container (in pixels)
		var maxX = view.container.offsetWidth;
		var maxY = view.container.offsetHeight;
		var screenPoints = [[m,m], [maxX-m,m], [maxX-m,maxY-m], [m,maxY-m]];
		var mapPoints = [];
		for (var p=0; p<screenPoints.length; p++) {
			var screenPoint = new Point({x: screenPoints[p][0], y: screenPoints[p][1], z: 0});
			var mapPoint = view.toMap(screenPoint);
			if (!mapPoint)
				return null;
			mapPoints.push([mapPoint.x, mapPoint.y, mapPoint.z]);
		}
		mapPoints.push(mapPoints[0]);
		var newPolygon = new Polygon(mapPoints);
		return newPolygon;
	}


	  
	function getSubLayerID(mapImageLayer, subLayerName) {
		var li = mapImageLayer.allSublayers;
		var layerName = subLayerName[0];
		for (var i=0; i<li.length; i++) {
			if (li.items[i].title==subLayerName)
				 return li.items[i].id;
			}
		return -1;
	}
	  
	// Function that performs all of the necessary one-time setup when the application is first loaded.
	// Function is not executed until the ShoreZone map service is fully loaded.
	function init(){   
		console.log( 'LOADING LAYERS...' );
		loadLayers(); // Load the layers into the map.
		console.log( 'BUILDING UEM...' );
		UEM = buildUEM( initial_EM_height );
		map.add( UEM );
		// Once we've assined the UEM layer to the Map, the layer has an ID that we can record to make later references to the layer easy
		map.UEM_ID = UEM.id;
		// Add watchers to all of the layers. Each watcher fires when it's layer's visibility changes. Calls fireOnVisibilityChange()
		console.log( 'SETTING WATCHERS...' );
		setWatchers(); 
		// Create the legend widget, add the layers to it, and add it to the map.
		console.log( 'BUILDING LEGEND...' );
		createLegend();
		console.log( 'BUILDING LAYER LIST...' );
		createLayerList();
	};
	
	// Now that all of our code is defined and ready, we load the map service, which will trigger the initialization of the entire app.
	szMapService.load()  
	// Function that fires once the szMapService has completely loaded. Since we have to wait for that to initialize basically every part of the web app, we just wait and then call the init() function, which intitializes all of the layers and widgets that we need.
	szMapService.then(
		function() {
			init();
		}
	);
});

	  




</script>
</head>

<body>
<div id="viewDiv"></div>
<div id="elevationDiv">
	<table>
		<tr>
			<td>Layer spacing:</td>
			<td><input id="offsetInput" type="text" size="5" value="100"></td>
		</tr>
		<!--<tr> Adds a button to the UI, which can be linked to the query testing functionality a few lines above.
			<td><input type="button" id="queryButton" name="queryButton" value="Query"</td>
		</tr>-->
	</table>
</div>
</body>
</html>